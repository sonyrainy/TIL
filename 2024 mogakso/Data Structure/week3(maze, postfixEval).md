- **Stack Maze**
> 2차원 행렬에서 0과 1로 이루어진 미로가 있다고 보자.
> 
> 여기서, 0이면 갈 수 있는 길, 1이면 막힌 길로 생각한다. stack을 활용해서 미로를 어떻게 빠져나갈 수 있을지 파악한다.

+) mark라는 array를 만들어 갔던 곳을 표시한다.

+) 미로의 가장자리를 표현하기 위해 행과 열에 추가적으로 +1만큼의 공간을 추가하여 미로를 받는다.

![image](https://github.com/sonyrainy/TIL/assets/91364766/2a71eef2-b96d-4914-a6b2-85fdb118e7f6)

위 그림에서 (1,1)를 시작 부분으로 두고 (북 → 북동 → 동 → 남동 → 남 ...) 시계 방향으로 뻗어나갈 수 있는지 여부를 파악한다.

(1,1)에서 동쪽으로 갈 수 있으니까 이동한다. ```(1,1,E(동))```으로 이동했으니까, Stack에는 ```(1,1,ES(남동))```을 push 해둔다. (1,1,E)로 간 것이 실패하면, (1,1,ES)의 길을 
새로 조사해야 하기 때문이다.

위 내용을 반복하는데 세부 내용은 아래와 같다.

+) 가다가 길이 막혀있으면 Stack에서 가장 최근에 넣은(가보지 않은 곳(or 방향)) 부분으로 가는 것을 pop 한다. 그 다음 막혔을 때 조사할 
방향은 Stack에 넣어둔다.

ex) (2,4,NE)로 갔을 때, 막혀있었으니까 Stack에 저장되어 있던 (2,4,E)를 pop(2,4,E)한다. 그리고, Stack에 [push(2,4,W)]를 한다. push(2,4,SW)으로 가서 (3,3)으로 이동 할 수 있었기 때문이다.

+) push할 때, 해당 부분을 mark에 표시한다(이동 경로에 포함된 부분이라는 것).

+) pop할 때는 해당 부분 mark를 없앤다(경로에 미포함). 바로 다음에 조사할 부분은 mark에 표시한다.

ex) 위 ex) 내용을 이어서 설명하자면, (3,3)으로 이동하고, (3,3,SE)로 이동할 것이다. 따라서, 이후 막혔을 때 조사할 (Stack에 넣을) 값으로 (3,3,S)를 넣는다. 
만약 (3,3)으로 돌아온다면 (3,3,S)가 막혀있음이 파악되고 (3,3,WS) 방향으로 이동하게 될 것이다.

세부내용을 포함한 위 내용을 반복하면 미로를 탈출할 수 있다.

<br>

- **Stack-postfix Evaluation**
  - Infix notation
  - Prefix notation
  - Postfix notation
