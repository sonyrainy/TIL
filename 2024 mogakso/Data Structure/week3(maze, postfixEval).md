Stack을 활용하여 미로 탈출, postfix Evaluation을 표현해보았다.

---

- **Stack Maze**
> 2차원 행렬에서 0과 1로 이루어진 미로가 있다고 보자.
> 
> 여기서, 0이면 갈 수 있는 길, 1이면 막힌 길로 생각한다. stack을 활용해서 미로를 어떻게 빠져나갈 수 있을지 파악한다.

+) mark라는 array를 만들어 갔던 곳을 표시한다.

+) 미로의 가장자리를 표현하기 위해 행과 열에 추가적으로 +1만큼의 공간을 추가하여 미로를 받는다.

![image](https://github.com/sonyrainy/TIL/assets/91364766/d098d6e5-9a22-4193-8b8b-a5e6ba8e0a54)

위 그림에서 (1,1)를 시작 부분으로 두고 (북 → 북동 → 동 → 남동 → 남 ...) 시계 방향으로 뻗어나갈 수 있는지 여부를 파악한다.

(1,1)에서 동쪽으로 갈 수 있으니까 이동한다. ```(1,1,E(동))```으로 이동했으니까, Stack에는 ```(1,1,ES(남동))```을 push 해둔다. (1,1,E)로 간 것이 실패하면, (1,1,ES)의 길을 
새로 조사해야 하기 때문이다.

위 내용을 반복하는데 세부 내용은 아래와 같다.

+) 가다가 길이 막혀있으면 Stack에서 가장 최근에 넣은(가보지 않은 곳(or 방향)) 부분으로 가는 것을 pop 한다. 그 다음 막혔을 때 조사할 
방향은 Stack에 넣어둔다.

ex) (2,4,NE)로 갔을 때, 막혀있었으니까 Stack에 저장되어 있던 (2,4,E)를 pop(2,4,E)한다. 그리고, Stack에 [push(2,4,W)]를 한다. push(2,4,SW)으로 가서 (3,3)으로 이동 할 수 있었기 때문이다.

+) push할 때, 해당 부분을 mark에 표시한다(이동 경로에 포함된 부분이라는 것).

+) pop할 때는 해당 부분 mark를 없앤다(경로에 미포함). 바로 다음에 조사할 부분은 mark에 표시한다.

ex) 위 ex) 내용을 이어서 설명하자면, (3,3)으로 이동하고, (3,3,SE)로 이동할 것이다. 따라서, 이후 막혔을 때 조사할 (Stack에 넣을) 값으로 (3,3,S)를 넣는다. 
만약 (3,3)으로 돌아온다면 (3,3,S)가 막혀있음이 파악되고 (3,3,WS) 방향으로 이동하게 될 것이다.

세부내용을 포함한 위 내용을 반복하면 미로를 탈출할 수 있다.

<br>

- **Stack-postfix Evaluation**
  - Infix notation : 7+5*2-8/4 → {7+(5*2)}-(8/4) 
  - Prefix notation : -+7*52/84 → -{+7(*52)}(/84)
  - Postfix notation : 752*+84/- → {7(52*)+}(84/)- → 15
 
>위 3가지 종류 중 Postfix Notation을 stack을 활용해 표현해보고자 한다.

A/B-C+D*E-A*C → AB/C-DE*+AC*- 바로 변환되는 String이 찍히도록 하고자 한다.

우선순위 정보를 고려한다. 괄호의 시작(()이 괄호가 끝날 때까지는 Stack에 저장되어 있어야 한다. 우선 순위가 괄호 내부의 operator보다 낮으니까 머물러있는 것으로 보면 된다.

<br>

ex_1) a+b*c → abc*+

operand는 일단 그냥 출력하고, operator(+,* ...)는 Stack에 넣는다.

a는 출력한다. +를 0번째 Stack에 넣고, b를 출력하고, *를 1번째 Stack에 넣는다(+가 *의 우선순위보다 낮으니까 그냥 넣는다. Stack에 먼저 들어가있는 것의 우선순위가 더 높다면 먼저 들어가있던 operator을 먼저 출력(pop)하고, 이후에 나온 operator을 Stack에 push한다.).
c를 출력한다. Stack의 top부터 차례대로 출력한다.

```abc*+```가 출력된다.

<br>

ex_2) a*(b+c)*d → abc+*d*

1. a를 출력한다.
2. stack 0번째에 *를 push한다.
3. (는 stack 1번째에 넣는다. 괄호의 우선순위가 그 어느 operand보다 크기 때문에 그냥 넣으면 된다.
4. b를 출력한다.
5. +를 stack 2번째에 넣는다(오른쪽 괄호가 나올 때까지 stack에 ex_1의 원칙에 따라 진행하면 된다.)
6. c를 출력한다. 오른쪽 괄호가 나왔으므로, 왼쪽 괄호를 stack에서 삭제한다.
7. c 다음으로 *가 나왔는데, Stack의 0번째에 있는 *와 우선순위를 고려했을 때 먼저 들어온 0번째의 *가 더 우선순위가 높으므로, 해당 *를 출력(pop)한다. c 다음에 있던 *는 Stack의 0번째 자리로 들어간다.
8. d를 출력하고, 끝났으므로 Stack의 0번째 자리에 있는 *를 출력한다.

```abc+*d*```가 출력된다.
